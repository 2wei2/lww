assume cs:code,ds:data,ss:stack
data segment
db 'welcome to masm!'  ;定义显示的字符串(16字节)
db 02h,24h,71h		   ;定义三种颜色属性 
data ends

stack segment ;栈段用来存放cx做多重循环
dw 8 dup(0)
stack ends

code segment
start:
mov ax,data
mov ds,ax
mov ax,stack
mov ss,ax
mov sp,10h

mov bx,0
mov ax,0b872h  		  ;算出中间位置段地址
mov es,ax
mov bp,10h ;作为颜色数据的指针
mov cx,3  			  ;3次大循环
s:
push cx
mov si,0;作为字符串的指针
mov di,0;作为目标地址的指针
mov cx,16 ;小循环16次

s0:
mov al,ds:[si] ;获取字符串的数据
mov es:[di+bx],al ;将字符串的数据低位保存到目标地址
inc di 		   ;目标地址前进
mov al,ds:[bp] ;获取颜色属性数据
mov es:[di+bx],al ;将颜色属性数据高位保存到目标地址
inc di		   ;目标地址前进
inc si         ;字符串前进
loop s0

pop cx 
add bx,0a0h ;进行下一行
inc bp     ;颜色也要变化
loop s 
mov ax,4c00h
int 21h

code ends 
end start

————————————我是分界线T^T——————————————————————————



assume cs:codesg

datasg segment
	db "Beginner's All-purpose Symbolic Instruction Code.",0
datasg ends

codesg segment
	begin:	mov ax,datasg
			mov ds,ax
			mov si,0
			call letterc
			
			mov ax,4c00h
			int 21h

  letterc:	push cx
  			mov ch,0
  			
  		s:	mov cl,[si]
  			jcxz endl
  			
  			cmp cl,97
  			jb next
  			cmp cl,122
  			ja next
  			
  			and cl,11011111b
  			mov [si],cl
  			
  	 next:	inc si
  	 		jmp short s

  	 endl:	pop cx
			ret
codesg ends
end begin

————————————————————分界线——————————————————————

​		实验10.1

assume cs:code

	data segment
		db 'Welcome to masm!', 0
	data ends
	
	code segment
	start:		mov dh, 8
				mov dl, 3
				mov cl, 2
				mov ax, data
				mov ds, ax
				mov si, 0
				call show_str
				mov ax, 4c00h
				int 21h
	
	show_str:	push ax
				push bx
				push cx
				push dx
				push es
				push di
				push si
				;根据上节中的框架，为了不让子程序干扰主程序中寄存器的值，将所有子程序会用到的寄存器进行压栈
	
				mov ax, 0b800h
				mov es, ax
				;颜色区的段地址
				mov al, 160 
				mul dh
				;每行占160个字节，乘以行数
				push ax
				;将行计算的结果存储到栈中
				mov al, 2
				mul dl
				;每列占2个字节，乘以列数
				pop bx
				;将上次运算的结果（160×行数）的值转移到bx中
				add bx, ax	;此时的ax值为（2×列数）
				;将两者相加，最终结果保存到bx中
				mov dl, cl
				;因为下面的跳转指令jcxz需要用到cx寄存器，故需要将cl的值先保存在dl中
				mov di, 0
	change:		mov cl, ds:[di]
				mov ch, 0
				jcxz ok
				mov ch, dl 
				mov es:[bx+si], cx
				add si, 2 
				inc di
				jmp short change
	
	ok:			pop si
				pop di
				pop es
				pop dx
				pop cx
				pop bx
				pop ax
				ret
	
	code ends
	end start
10.3

assume cs:code,ds:data,ss:stack
data segment
db 20 dup(0)
data ends
stack segment
dw 20 dup(0)
stack ends 

code segment
start:
mov bx,data
mov ds,bx
mov bx,stack
mov ss,bx
mov sp,40

mov ax,12345
mov si,0

call dtoc 	;将word型数据转变成十进制字符串,字符串以0结尾,存放于data段

mov dh,12
mov dl,64
mov cl,02h
mov si,0
call showptr ;显示字符串 dh是行,dl是列,cl是颜色,ds:si指向字符串首地址

mov ax,4c00h
int 21h

dtoc:
push ax
push bx
push cx
push dx
push di
push si

mov bx,10;除数为10
mov di,0 ;计数器置0

s0:
mov dx,0 ;被除数高位置0
div bx   ;做除法 dx存放余数 ax存放商


add dx,30h ;余数加30h
push dx    ;存放ascii码,入栈
inc di     ;计数器加1
;判断商是否为0
mov cx,ax 
jcxz dtoc_ok
jmp short s0 ;跳转回去继续做除法直到商为0

dtoc_ok:
;inc di 
mov cx,di  ;计数器存进cx做循环
;inc cx 
s2:
pop ds:[si];出栈 弹出到data空间
inc si     ;指针后移
loop s2    ;结束循环表示出栈成功
;归还寄存器
pop si 
pop di
pop dx 
pop cx 
pop bx 
pop ax 
ret

showptr: ;将用到的寄存器统统存储一遍，后续结束小程序时全部返还
push di
push dx
push cx
push si 
push ds 
push es
push ax


show:
;将字符串显示在屏幕上，dh是行,dl是列,cl是颜色,ds:si指向字符串首地址
;1.首先计算显存位置
sub dh,1  		;dh减一
mov al,dh 		;做乘法运算
mov ah,160
mul ah   		;行数减一乘以160 最后将结果ax加上dl即可
mov dh,0
add ax,dx 		;ax此时存放写入的地址位置
mov di,ax 		;作为显存指针使用
mov ax,0b800h
mov es,ax		;将显存地址写入es

;2.确定颜色属性
mov dh,cl 		;将颜色属性赋值高位过去

;3.写入字符串,ds:si指向字符串首地址,需要将字符串存放到dl中
show0:
;这里要利用jcxz了
mov ch,0
mov cl,ds:[si]
jcxz show_ok 
mov dl,ds:[si] 	;获取字符串字节
mov es:[di],dx  ;将dx写入到es:[di]中去 也就是显存地址
inc si 			;字符串指针后移
add di,2		;显存地址后移
jmp short show0 ;跳转回去

show_ok:;出口
pop ax
pop es 
pop ds 
pop si 
pop cx 
pop dx 
pop di 
ret
code ends
end start 